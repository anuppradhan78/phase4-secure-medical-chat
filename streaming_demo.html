<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Medical Chat - Streaming & Latency Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #34495e;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .demo-section {
            margin-bottom: 30px;
        }
        
        .chat-interface {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chat-panel {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: #fafafa;
        }
        
        .message-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .role-selector {
            margin-bottom: 10px;
        }
        
        .role-selector select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-left: 10px;
        }
        
        .send-button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .send-button:hover {
            background: #2980b9;
        }
        
        .send-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .benchmark-button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .benchmark-button:hover {
            background: #c0392b;
        }
        
        .response-area {
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            background: white;
            margin-top: 10px;
            font-family: monospace;
            font-size: 13px;
        }
        
        .latency-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .metric-label {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .pipeline-stage {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        
        .pipeline-stage.completed {
            border-left-color: #27ae60;
            background: #d5f4e6;
        }
        
        .pipeline-stage.error {
            border-left-color: #e74c3c;
            background: #fadbd8;
        }
        
        .stage-name {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .stage-duration {
            float: right;
            color: #7f8c8d;
            font-size: 12px;
        }
        
        .streaming-chunk {
            background: #e8f5e8;
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 4px;
            border-left: 3px solid #27ae60;
        }
        
        .error-message {
            background: #fadbd8;
            color: #c0392b;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .success-message {
            background: #d5f4e6;
            color: #27ae60;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .comparison-table th {
            background: #f2f2f2;
            font-weight: bold;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected {
            background: #27ae60;
        }
        
        .status-disconnected {
            background: #e74c3c;
        }
        
        .status-processing {
            background: #f39c12;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            background: none;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom-color: #3498db;
            color: #3498db;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè• Secure Medical Chat - Streaming & Latency Optimization Demo</h1>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('streaming')">Streaming Chat</button>
            <button class="tab" onclick="showTab('latency')">Latency Analytics</button>
            <button class="tab" onclick="showTab('comparison')">Provider Comparison</button>
            <button class="tab" onclick="showTab('benchmark')">Performance Benchmark</button>
        </div>
        
        <!-- Streaming Chat Tab -->
        <div id="streaming" class="tab-content active">
            <div class="demo-section">
                <h2>Real-time Streaming Chat with Security Pipeline</h2>
                <p>Experience real-time response streaming while maintaining full security controls and latency measurement.</p>
                
                <div class="chat-interface">
                    <div class="chat-panel">
                        <h3>Chat Input</h3>
                        <div class="role-selector">
                            <label>User Role:</label>
                            <select id="userRole">
                                <option value="patient">Patient</option>
                                <option value="physician">Physician</option>
                                <option value="admin">Admin</option>
                            </select>
                        </div>
                        <textarea id="messageInput" class="message-input" rows="4" 
                                placeholder="Enter your medical question here...">I have been experiencing chest pain and shortness of breath for the past few hours. Should I be concerned?</textarea>
                        <div>
                            <button id="sendStreamingBtn" class="send-button" onclick="sendStreamingMessage()">
                                Send Streaming
                            </button>
                            <button id="sendRegularBtn" class="send-button" onclick="sendRegularMessage()">
                                Send Regular
                            </button>
                        </div>
                        
                        <div class="metric-card" style="margin-top: 15px;">
                            <div class="status-indicator" id="connectionStatus"></div>
                            <span id="connectionText">Disconnected</span>
                        </div>
                    </div>
                    
                    <div class="chat-panel">
                        <h3>Pipeline Progress</h3>
                        <div id="pipelineProgress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="overallProgress"></div>
                            </div>
                            <div id="pipelineStages"></div>
                        </div>
                    </div>
                </div>
                
                <div class="response-area" id="streamingResponse"></div>
                
                <div class="latency-metrics" id="streamingMetrics">
                    <!-- Metrics will be populated dynamically -->
                </div>
            </div>
        </div>
        
        <!-- Latency Analytics Tab -->
        <div id="latency" class="tab-content">
            <div class="demo-section">
                <h2>Latency Analytics Dashboard</h2>
                <p>Comprehensive latency analysis with breakdown by pipeline stages and optimization recommendations.</p>
                
                <div style="margin-bottom: 20px;">
                    <label>Analysis Period:</label>
                    <select id="analyticsPeriod" onchange="loadLatencyAnalytics()">
                        <option value="1">Last Hour</option>
                        <option value="24" selected>Last 24 Hours</option>
                        <option value="168">Last Week</option>
                    </select>
                    <button class="send-button" onclick="loadLatencyAnalytics()" style="margin-left: 10px;">
                        Refresh Analytics
                    </button>
                </div>
                
                <div class="latency-metrics" id="analyticsMetrics">
                    <!-- Analytics will be populated dynamically -->
                </div>
                
                <div id="stageBreakdown"></div>
                <div id="performanceRecommendations"></div>
            </div>
        </div>
        
        <!-- Provider Comparison Tab -->
        <div id="comparison" class="tab-content">
            <div class="demo-section">
                <h2>Provider & Model Performance Comparison</h2>
                <p>Compare latency performance across different LLM providers and models.</p>
                
                <div style="margin-bottom: 20px;">
                    <button class="send-button" onclick="loadProviderComparison()">
                        Load Comparison Data
                    </button>
                </div>
                
                <div id="comparisonResults">
                    <!-- Comparison results will be populated dynamically -->
                </div>
            </div>
        </div>
        
        <!-- Performance Benchmark Tab -->
        <div id="benchmark" class="tab-content">
            <div class="demo-section">
                <h2>Performance Benchmark Testing</h2>
                <p>Run controlled benchmark tests to measure baseline system performance.</p>
                
                <div style="margin-bottom: 20px;">
                    <label>Benchmark Iterations:</label>
                    <select id="benchmarkIterations">
                        <option value="3">3 iterations</option>
                        <option value="5" selected>5 iterations</option>
                        <option value="10">10 iterations</option>
                    </select>
                    <button class="benchmark-button" onclick="runBenchmark()" style="margin-left: 10px;">
                        Run Benchmark
                    </button>
                </div>
                
                <div id="benchmarkProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="benchmarkProgressBar"></div>
                    </div>
                    <div id="benchmarkStatus"></div>
                </div>
                
                <div id="benchmarkResults">
                    <!-- Benchmark results will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let currentRequestId = null;
        
        // Tab management
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Load data for specific tabs
            if (tabName === 'latency') {
                loadLatencyAnalytics();
            } else if (tabName === 'comparison') {
                loadProviderComparison();
            }
        }
        
        // Streaming chat functionality
        function sendStreamingMessage() {
            const message = document.getElementById('messageInput').value;
            const userRole = document.getElementById('userRole').value;
            
            if (!message.trim()) {
                alert('Please enter a message');
                return;
            }
            
            // Disable send button
            document.getElementById('sendStreamingBtn').disabled = true;
            document.getElementById('sendRegularBtn').disabled = true;
            
            // Clear previous response
            document.getElementById('streamingResponse').innerHTML = '';
            document.getElementById('streamingMetrics').innerHTML = '';
            document.getElementById('pipelineStages').innerHTML = '';
            
            // Update connection status
            updateConnectionStatus('processing', 'Processing...');
            
            // Initialize pipeline stages
            initializePipelineStages();
            
            // Start streaming
            startStreaming(message, userRole);
        }
        
        function sendRegularMessage() {
            const message = document.getElementById('messageInput').value;
            const userRole = document.getElementById('userRole').value;
            
            if (!message.trim()) {
                alert('Please enter a message');
                return;
            }
            
            // Disable send button
            document.getElementById('sendStreamingBtn').disabled = true;
            document.getElementById('sendRegularBtn').disabled = true;
            
            // Clear previous response
            document.getElementById('streamingResponse').innerHTML = '';
            document.getElementById('streamingMetrics').innerHTML = '';
            
            // Update connection status
            updateConnectionStatus('processing', 'Processing...');
            
            // Send regular request
            sendRegularRequest(message, userRole);
        }
        
        function startStreaming(message, userRole) {
            // Close existing connection
            if (eventSource) {
                eventSource.close();
            }
            
            // Create new EventSource
            eventSource = new EventSource('/api/chat/stream', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-User-Role': userRole,
                    'X-User-ID': 'demo_user',
                    'X-Session-ID': 'demo_session_' + Date.now()
                }
            });
            
            // Note: EventSource doesn't support POST with body directly
            // We'll use fetch with streaming instead
            streamWithFetch(message, userRole);
        }
        
        async function streamWithFetch(message, userRole) {
            try {
                const response = await fetch('/api/chat/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-User-Role': userRole,
                        'X-User-ID': 'demo_user',
                        'X-Session-ID': 'demo_session_' + Date.now()
                    },
                    body: JSON.stringify({
                        message: message,
                        user_role: userRole,
                        session_id: 'demo_session_' + Date.now()
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                updateConnectionStatus('connected', 'Connected - Streaming');
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        break;
                    }
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleStreamingEvent(data);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e);
                            }
                        }
                    }
                }
                
                updateConnectionStatus('disconnected', 'Disconnected');
                
            } catch (error) {
                console.error('Streaming error:', error);
                displayError('Streaming failed: ' + error.message);
                updateConnectionStatus('disconnected', 'Error');
            } finally {
                // Re-enable send buttons
                document.getElementById('sendStreamingBtn').disabled = false;
                document.getElementById('sendRegularBtn').disabled = false;
            }
        }
        
        async function sendRegularRequest(message, userRole) {
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-User-Role': userRole,
                        'X-User-ID': 'demo_user',
                        'X-Session-ID': 'demo_session_' + Date.now()
                    },
                    body: JSON.stringify({
                        message: message,
                        user_role: userRole,
                        session_id: 'demo_session_' + Date.now()
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Display response
                displayRegularResponse(data);
                updateConnectionStatus('disconnected', 'Completed');
                
            } catch (error) {
                console.error('Request error:', error);
                displayError('Request failed: ' + error.message);
                updateConnectionStatus('disconnected', 'Error');
            } finally {
                // Re-enable send buttons
                document.getElementById('sendStreamingBtn').disabled = false;
                document.getElementById('sendRegularBtn').disabled = false;
            }
        }
        
        function handleStreamingEvent(data) {
            const responseArea = document.getElementById('streamingResponse');
            
            switch (data.type) {
                case 'connection':
                    currentRequestId = data.request_id;
                    appendToResponse(`üîó Connected - Request ID: ${data.request_id}`, 'success-message');
                    break;
                    
                case 'stage_start':
                    updatePipelineStage(data.stage, 'processing', data.message);
                    appendToResponse(`‚è≥ ${data.stage}: ${data.message}`, 'pipeline-stage');
                    break;
                    
                case 'stage_complete':
                    updatePipelineStage(data.stage, 'completed');
                    appendToResponse(`‚úÖ ${data.stage} completed`, 'pipeline-stage completed');
                    break;
                    
                case 'cache_hit':
                    appendToResponse(`üíæ Cache Hit: ${data.message} (Model: ${data.model})`, 'success-message');
                    break;
                    
                case 'chunk':
                    appendToResponse(data.text, 'streaming-chunk');
                    break;
                    
                case 'complete':
                    appendToResponse(`‚úÖ Request completed successfully`, 'success-message');
                    displayStreamingMetrics(data.metadata, data.latency_breakdown);
                    updateOverallProgress(100);
                    break;
                    
                case 'error':
                    updatePipelineStage(data.stage || 'unknown', 'error');
                    appendToResponse(`‚ùå Error: ${data.message}`, 'error-message');
                    break;
            }
        }
        
        function displayRegularResponse(data) {
            const responseArea = document.getElementById('streamingResponse');
            
            // Display response
            appendToResponse(`üí¨ Response: ${data.response}`, 'streaming-chunk');
            
            // Display metadata
            displayStreamingMetrics(data.metadata, data.metadata.latency_breakdown);
        }
        
        function appendToResponse(text, className = '') {
            const responseArea = document.getElementById('streamingResponse');
            const div = document.createElement('div');
            div.className = className;
            div.textContent = text;
            responseArea.appendChild(div);
            responseArea.scrollTop = responseArea.scrollHeight;
        }
        
        function displayError(message) {
            appendToResponse(message, 'error-message');
        }
        
        function updateConnectionStatus(status, text) {
            const indicator = document.getElementById('connectionStatus');
            const textElement = document.getElementById('connectionText');
            
            indicator.className = 'status-indicator status-' + status;
            textElement.textContent = text;
        }
        
        function initializePipelineStages() {
            const stages = [
                'authentication', 'rate_limiting', 'pii_redaction', 
                'guardrails_validation', 'medical_safety', 'llm_processing',
                'response_validation', 'de_anonymization', 'audit_logging'
            ];
            
            const container = document.getElementById('pipelineStages');
            container.innerHTML = '';
            
            stages.forEach(stage => {
                const div = document.createElement('div');
                div.id = `stage_${stage}`;
                div.className = 'pipeline-stage';
                div.innerHTML = `
                    <span class="stage-name">${stage.replace(/_/g, ' ').toUpperCase()}</span>
                    <span class="stage-duration" id="duration_${stage}">Pending</span>
                `;
                container.appendChild(div);
            });
        }
        
        function updatePipelineStage(stageName, status, message = '') {
            const stageElement = document.getElementById(`stage_${stageName}`);
            if (stageElement) {
                stageElement.className = `pipeline-stage ${status}`;
                if (message) {
                    stageElement.querySelector('.stage-duration').textContent = message;
                }
            }
        }
        
        function updateOverallProgress(percentage) {
            const progressBar = document.getElementById('overallProgress');
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }
        
        function displayStreamingMetrics(metadata, latencyBreakdown) {
            const metricsContainer = document.getElementById('streamingMetrics');
            
            const metrics = [
                { label: 'Total Latency', value: `${metadata.latency_ms}ms`, key: 'latency_ms' },
                { label: 'Model Used', value: metadata.model_used, key: 'model_used' },
                { label: 'Cost', value: `$${metadata.cost.toFixed(4)}`, key: 'cost' },
                { label: 'Cache Hit', value: metadata.cache_hit ? 'Yes' : 'No', key: 'cache_hit' },
                { label: 'Entities Redacted', value: metadata.redaction_info.entities_redacted, key: 'entities_redacted' },
                { label: 'Pipeline Stages', value: metadata.pipeline_stages.length, key: 'pipeline_stages' }
            ];
            
            metricsContainer.innerHTML = '';
            
            metrics.forEach(metric => {
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <div class="metric-value">${metric.value}</div>
                    <div class="metric-label">${metric.label}</div>
                `;
                metricsContainer.appendChild(card);
            });
            
            // Display latency breakdown if available
            if (latencyBreakdown) {
                const breakdownCard = document.createElement('div');
                breakdownCard.className = 'metric-card';
                breakdownCard.style.gridColumn = '1 / -1';
                
                let breakdownHtml = '<h4>Latency Breakdown</h4>';
                for (const [stage, duration] of Object.entries(latencyBreakdown)) {
                    breakdownHtml += `<div>${stage.replace(/_/g, ' ')}: ${duration.toFixed(1)}ms</div>`;
                }
                
                breakdownCard.innerHTML = breakdownHtml;
                metricsContainer.appendChild(breakdownCard);
            }
        }
        
        // Latency Analytics
        async function loadLatencyAnalytics() {
            const period = document.getElementById('analyticsPeriod').value;
            
            try {
                const response = await fetch(`/api/latency/analytics?period_hours=${period}`, {
                    headers: {
                        'X-User-Role': 'admin',
                        'X-User-ID': 'demo_admin'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                displayLatencyAnalytics(data.analytics);
                
            } catch (error) {
                console.error('Failed to load analytics:', error);
                document.getElementById('analyticsMetrics').innerHTML = 
                    '<div class="error-message">Failed to load analytics: ' + error.message + '</div>';
            }
        }
        
        function displayLatencyAnalytics(analytics) {
            const container = document.getElementById('analyticsMetrics');
            
            if (analytics.total_requests === 0) {
                container.innerHTML = '<div class="error-message">No data available for the selected period</div>';
                return;
            }
            
            const metrics = [
                { label: 'Total Requests', value: analytics.total_requests },
                { label: 'Avg Latency', value: `${analytics.overall_stats.avg_latency_ms}ms` },
                { label: 'P95 Latency', value: `${analytics.overall_stats.p95_latency_ms}ms` },
                { label: 'Cache Hit Rate', value: `${(analytics.cache_performance.cache_hit_rate * 100).toFixed(1)}%` },
                { label: 'Performance Score', value: analytics.performance_analysis.performance_score.score || 'N/A' }
            ];
            
            container.innerHTML = '';
            
            metrics.forEach(metric => {
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <div class="metric-value">${metric.value}</div>
                    <div class="metric-label">${metric.label}</div>
                `;
                container.appendChild(card);
            });
            
            // Display stage breakdown
            displayStageBreakdown(analytics.stage_breakdown);
            
            // Display recommendations
            displayRecommendations(analytics.performance_analysis);
        }
        
        function displayStageBreakdown(stageBreakdown) {
            const container = document.getElementById('stageBreakdown');
            
            let html = '<h3>Pipeline Stage Performance</h3>';
            html += '<table class="comparison-table">';
            html += '<tr><th>Stage</th><th>Avg Duration</th><th>P95 Duration</th><th>Status</th></tr>';
            
            for (const [stageName, stats] of Object.entries(stageBreakdown)) {
                const status = stats.performance_vs_baseline === 'good' ? '‚úÖ Good' : '‚ö†Ô∏è Slow';
                html += `
                    <tr>
                        <td>${stageName.replace(/_/g, ' ')}</td>
                        <td>${stats.avg_duration_ms}ms</td>
                        <td>${stats.p95_duration_ms}ms</td>
                        <td>${status}</td>
                    </tr>
                `;
            }
            
            html += '</table>';
            container.innerHTML = html;
        }
        
        function displayRecommendations(performanceAnalysis) {
            const container = document.getElementById('performanceRecommendations');
            
            let html = '<h3>Performance Recommendations</h3>';
            
            if (performanceAnalysis.issues && performanceAnalysis.issues.length > 0) {
                html += '<h4>Issues Detected:</h4><ul>';
                performanceAnalysis.issues.forEach(issue => {
                    html += `<li><strong>${issue.type}</strong>: ${issue.description}</li>`;
                });
                html += '</ul>';
            }
            
            if (performanceAnalysis.recommendations && performanceAnalysis.recommendations.length > 0) {
                html += '<h4>Recommendations:</h4><ul>';
                performanceAnalysis.recommendations.forEach(rec => {
                    html += `<li><strong>${rec.type}</strong> (${rec.priority}): ${rec.action}</li>`;
                });
                html += '</ul>';
            }
            
            container.innerHTML = html;
        }
        
        // Provider Comparison
        async function loadProviderComparison() {
            try {
                const response = await fetch('/api/latency/comparison?period_hours=24', {
                    headers: {
                        'X-User-Role': 'admin',
                        'X-User-ID': 'demo_admin'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                displayProviderComparison(data.comparison);
                
            } catch (error) {
                console.error('Failed to load comparison:', error);
                document.getElementById('comparisonResults').innerHTML = 
                    '<div class="error-message">Failed to load comparison: ' + error.message + '</div>';
            }
        }
        
        function displayProviderComparison(comparison) {
            const container = document.getElementById('comparisonResults');
            
            if (comparison.message) {
                container.innerHTML = `<div class="error-message">${comparison.message}</div>`;
                return;
            }
            
            let html = '<h3>Model Performance Comparison</h3>';
            html += '<table class="comparison-table">';
            html += '<tr><th>Model</th><th>Requests</th><th>Avg Latency</th><th>P95 Latency</th><th>Cache Hit Rate</th><th>Performance</th></tr>';
            
            for (const [model, stats] of Object.entries(comparison)) {
                if (model === 'summary') continue;
                
                const performance = stats.performance_metrics?.performance_vs_baseline || 'unknown';
                const performanceIcon = performance === 'excellent' ? 'üü¢' : 
                                      performance === 'good' ? 'üü°' : 'üî¥';
                
                html += `
                    <tr>
                        <td>${model}</td>
                        <td>${stats.request_count || stats.latency_stats?.request_count || 0}</td>
                        <td>${stats.avg_latency_ms || stats.latency_stats?.avg_latency_ms || 0}ms</td>
                        <td>${stats.p95_latency_ms || stats.latency_stats?.p95_latency_ms || 0}ms</td>
                        <td>${((stats.cache_hit_rate || stats.cache_performance?.cache_hit_rate || 0) * 100).toFixed(1)}%</td>
                        <td>${performanceIcon} ${performance}</td>
                    </tr>
                `;
            }
            
            html += '</table>';
            
            // Add summary if available
            if (comparison.summary) {
                html += '<div class="success-message">';
                html += `<strong>Recommendation:</strong> ${comparison.summary.recommendation}`;
                html += '</div>';
            }
            
            container.innerHTML = html;
        }
        
        // Benchmark Testing
        async function runBenchmark() {
            const iterations = document.getElementById('benchmarkIterations').value;
            const progressContainer = document.getElementById('benchmarkProgress');
            const resultsContainer = document.getElementById('benchmarkResults');
            const progressBar = document.getElementById('benchmarkProgressBar');
            const statusElement = document.getElementById('benchmarkStatus');
            
            // Show progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            statusElement.textContent = 'Starting benchmark...';
            resultsContainer.innerHTML = '';
            
            try {
                const response = await fetch(`/api/latency/benchmark?iterations=${iterations}`, {
                    method: 'GET',
                    headers: {
                        'X-User-Role': 'admin',
                        'X-User-ID': 'demo_admin'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                // Simulate progress updates
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += 10;
                    progressBar.style.width = Math.min(progress, 90) + '%';
                    statusElement.textContent = `Running benchmark... ${Math.min(progress, 90)}%`;
                }, 200);
                
                const data = await response.json();
                
                // Complete progress
                clearInterval(progressInterval);
                progressBar.style.width = '100%';
                statusElement.textContent = 'Benchmark completed!';
                
                // Display results
                displayBenchmarkResults(data);
                
                // Hide progress after delay
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error('Benchmark failed:', error);
                statusElement.textContent = 'Benchmark failed: ' + error.message;
                resultsContainer.innerHTML = 
                    '<div class="error-message">Benchmark failed: ' + error.message + '</div>';
            }
        }
        
        function displayBenchmarkResults(data) {
            const container = document.getElementById('benchmarkResults');
            
            const summary = data.benchmark_summary;
            
            let html = '<h3>Benchmark Results</h3>';
            
            if (summary.error) {
                html += `<div class="error-message">${summary.error}</div>`;
            } else {
                // Summary metrics
                html += '<div class="latency-metrics">';
                html += `<div class="metric-card"><div class="metric-value">${summary.iterations_completed}</div><div class="metric-label">Completed</div></div>`;
                html += `<div class="metric-card"><div class="metric-value">${summary.avg_latency_ms}ms</div><div class="metric-label">Avg Latency</div></div>`;
                html += `<div class="metric-card"><div class="metric-value">${summary.min_latency_ms}ms</div><div class="metric-label">Min Latency</div></div>`;
                html += `<div class="metric-card"><div class="metric-value">${summary.max_latency_ms}ms</div><div class="metric-label">Max Latency</div></div>`;
                html += `<div class="metric-card"><div class="metric-value">${summary.latency_std_dev}ms</div><div class="metric-label">Std Deviation</div></div>`;
                html += '</div>';
                
                // Stage breakdown
                if (summary.avg_stage_breakdown) {
                    html += '<h4>Average Stage Breakdown</h4>';
                    html += '<table class="comparison-table">';
                    html += '<tr><th>Stage</th><th>Average Duration</th></tr>';
                    
                    for (const [stage, duration] of Object.entries(summary.avg_stage_breakdown)) {
                        html += `<tr><td>${stage.replace(/_/g, ' ')}</td><td>${duration}ms</td></tr>`;
                    }
                    
                    html += '</table>';
                }
            }
            
            container.innerHTML = html;
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            updateConnectionStatus('disconnected', 'Disconnected');
            
            // Load initial analytics
            loadLatencyAnalytics();
        });
    </script>
</body>
</html>